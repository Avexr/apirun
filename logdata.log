2024-08-02 19:33:29 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u80fd\u591f\u6b63\u786e\u767b\u5f55\u7528\u4f8b] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:29 INFO 测试结果：passed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:29 INFO 故障表示：None conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:29 INFO 异常：None conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:29 INFO 用例耗时：0.05766950000000026 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:29 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:29 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u767b\u5f55\u5931\u8d25-\u624b\u673a\u53f7\u6216\u5bc6\u7801\u9519\u8bef\u7528\u4f8b] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:29 INFO 测试结果：passed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:29 INFO 故障表示：None conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:29 INFO 异常：None conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:29 INFO 用例耗时：0.049325600000000414 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:29 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:29 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u67e5\u770b\u7528\u6237\u4fe1\u606f] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:29 INFO 测试结果：passed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:29 INFO 故障表示：None conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:29 INFO 异常：None conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:29 INFO 用例耗时：0.07837059999999951 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:29 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:29 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u4fee\u6539\u5934\u50cf-\u4e0a\u4f20\u5934\u50cf] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:29 INFO 测试结果：passed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:29 INFO 故障表示：None conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:29 INFO 异常：None conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:29 INFO 用例耗时：0.08026300000000042 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:29 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:29 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u4fee\u6539\u5934\u50cf-\u786e\u5b9a\u4fee\u6539\u5934\u50cf] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:29 INFO 测试结果：passed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:29 INFO 故障表示：None conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:29 INFO 异常：None conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:29 INFO 用例耗时：0.09180060000000001 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:29 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:29 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u6211\u7684\u4e66\u8bc4-\u53d1\u5e03\u6b63\u5e38\u7684\u4e66\u8bc4(\u53ef\u80fd\u4f1a\u5931\u8d25)] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:29 INFO 测试结果：passed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:29 INFO 故障表示：None conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:29 INFO 异常：None conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:29 INFO 用例耗时：0.28582399999999986 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:29 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:30 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u6211\u7684\u4e66\u8bc4-\u53d1\u5e03\u4e0d\u5b58\u5728\u7684\u4e66\u7c4dID\uff08BUG\uff09] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:30 INFO 测试结果：failed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:30 INFO 故障表示：self = <ApiTestRunner.TestRunner object at 0x000002A9B1226700>
caseinfo = {'_case_name': '我的书评-发布不存在的书籍ID（BUG）', 'desc': '我的书评-发布不存在的书籍ID（BUG）', 'featureName': '我的书评', 'steps': [{'发送Post请求': {..., {'断言-等于-CODE': {'EXPECTED': '200', 'OP_STR': '==', 'VALUE': '{{msg_code}}', '关键字': 'assert_text_comparators'}}], ...}

    def test_case_execute(self, caseinfo):
        print("当前的测试数据：", caseinfo)
        # TODO 2-1: 动态生成一下当前的测试用例标题
        # allure.dynamic.title(caseinfo["_case_name"])
    
        # TODO 2-1 : 调用动态生成标题的方法
        dynamicTitle(caseinfo)
    
        # TODO 2-2: 基于我们步骤一步步进行执行
        try:
            # 实例化关键字对象
            keywords = KeyWords()
    
            # 获取当前用例变量，方便后续的渲染
            local_context = caseinfo.get("context",{})
            context = copy.deepcopy(g_context().show_dict())
            context.update(local_context)
    
            steps = caseinfo.get("steps", None)
            for step in steps:
                #  提示信息
                step_name = list(step.keys())[0]
                step_value = list(step.values())[0]
                print(f"开始执行步骤：{step_name} - {step_value}")
    
                # TODO : 每一个步骤进行变量的渲染
                context = copy.deepcopy(g_context().show_dict())
                context.update(local_context)
                step_value = eval(refresh(step_value, context))
    
                # 基于每个步骤的关键字，找到对应的方法，然后把参数给它
                #  通过【反射】的方式去找到对应的方法
                with allure.step(step_name):
                    key = step_value["关键字"]  # 具体的方法名, 在 keywords 里面找到这个方法
                    try:
                        key_func = keywords.__getattribute__(key)  # 从keywords获取到对应方法
                    except AttributeError as e:
                        print("没有这个关键字方法", e)
>                   key_func(**step_value)  # 调用方法

core\ApiTestRunner.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <extend.keywords.KeyWords object at 0x000002A9B12EA280>
kwargs = {'EXPECTED': '书籍ID不存在', 'OP_STR': '==', 'VALUE': 'SUCCESS', '关键字': 'assert_text_comparators'}
comparators = {'!=': <function KeyWords.assert_text_comparators.<locals>.<lambda> at 0x000002A9B13398B0>, '<': <function KeyWords.as...at 0x000002A9B1339820>, '==': <function KeyWords.assert_text_comparators.<locals>.<lambda> at 0x000002A9B1339700>, ...}
message = None

    @allure.step("参数数据：断言当前文本内容")
    def assert_text_comparators(self, **kwargs):
        """
        封装断言以进行不同的比较操作。
    
        参数:
        value (Any): 要比较的值。
        expected (Any): 预期的值。
        op_str (str): 操作符的字符串表示（如 '>', '<', '==' 等）。
        message (str, optional): 自定义的错误消息。
    
        返回:
        None: 如果断言成功，则不返回任何内容。
    
        引发:
        AssertionError: 如果断言失败。
        """
        comparators = {
            '>': lambda a, b: a > b,
            '<': lambda a, b: a < b,
            '==': lambda a, b: a == b,
            '>=': lambda a, b: a >= b,
            '<=': lambda a, b: a <= b,
            '!=': lambda a, b: a != b,
        }
    
        message = kwargs.get("MESSAGE", None)
    
        if kwargs["OP_STR"] not in comparators:
            raise ValueError(f"没有该操作方式: {kwargs['OP_STR']}")
    
        if not comparators[kwargs['OP_STR']](kwargs['VALUE'], kwargs["EXPECTED"]):
            if message:
                raise AssertionError(message)
            else:
>               raise AssertionError(f"{kwargs['VALUE']} {kwargs['OP_STR']} {kwargs['EXPECTED']} 失败")
E               AssertionError: SUCCESS == 书籍ID不存在 失败

extend\keywords.py:255: AssertionError conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:30 INFO 异常：<ExceptionInfo AssertionError('SUCCESS == 书籍ID不存在 失败') tblen=31> conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:30 INFO 用例耗时：0.08746429999999972 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:30 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:33 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u6211\u7684\u4e66\u8bc4-\u53d1\u5e03\u4e0d\u5b58\u5728\u7684\u4e66\u7c4dID\uff08BUG\uff09] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:33 INFO 测试结果：failed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:33 INFO 故障表示：self = <ApiTestRunner.TestRunner object at 0x000002A9B1226700>
caseinfo = {'_case_name': '我的书评-发布不存在的书籍ID（BUG）', 'desc': '我的书评-发布不存在的书籍ID（BUG）', 'featureName': '我的书评', 'steps': [{'发送Post请求': {..., {'断言-等于-CODE': {'EXPECTED': '200', 'OP_STR': '==', 'VALUE': '{{msg_code}}', '关键字': 'assert_text_comparators'}}], ...}

    def test_case_execute(self, caseinfo):
        print("当前的测试数据：", caseinfo)
        # TODO 2-1: 动态生成一下当前的测试用例标题
        # allure.dynamic.title(caseinfo["_case_name"])
    
        # TODO 2-1 : 调用动态生成标题的方法
        dynamicTitle(caseinfo)
    
        # TODO 2-2: 基于我们步骤一步步进行执行
        try:
            # 实例化关键字对象
            keywords = KeyWords()
    
            # 获取当前用例变量，方便后续的渲染
            local_context = caseinfo.get("context",{})
            context = copy.deepcopy(g_context().show_dict())
            context.update(local_context)
    
            steps = caseinfo.get("steps", None)
            for step in steps:
                #  提示信息
                step_name = list(step.keys())[0]
                step_value = list(step.values())[0]
                print(f"开始执行步骤：{step_name} - {step_value}")
    
                # TODO : 每一个步骤进行变量的渲染
                context = copy.deepcopy(g_context().show_dict())
                context.update(local_context)
                step_value = eval(refresh(step_value, context))
    
                # 基于每个步骤的关键字，找到对应的方法，然后把参数给它
                #  通过【反射】的方式去找到对应的方法
                with allure.step(step_name):
                    key = step_value["关键字"]  # 具体的方法名, 在 keywords 里面找到这个方法
                    try:
                        key_func = keywords.__getattribute__(key)  # 从keywords获取到对应方法
                    except AttributeError as e:
                        print("没有这个关键字方法", e)
>                   key_func(**step_value)  # 调用方法

core\ApiTestRunner.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <extend.keywords.KeyWords object at 0x000002A9B1330520>
kwargs = {'EXPECTED': '书籍ID不存在', 'OP_STR': '==', 'VALUE': 'SUCCESS', '关键字': 'assert_text_comparators'}
comparators = {'!=': <function KeyWords.assert_text_comparators.<locals>.<lambda> at 0x000002A9B1324E50>, '<': <function KeyWords.as...at 0x000002A9B1324C10>, '==': <function KeyWords.assert_text_comparators.<locals>.<lambda> at 0x000002A9B1324EE0>, ...}
message = None

    @allure.step("参数数据：断言当前文本内容")
    def assert_text_comparators(self, **kwargs):
        """
        封装断言以进行不同的比较操作。
    
        参数:
        value (Any): 要比较的值。
        expected (Any): 预期的值。
        op_str (str): 操作符的字符串表示（如 '>', '<', '==' 等）。
        message (str, optional): 自定义的错误消息。
    
        返回:
        None: 如果断言成功，则不返回任何内容。
    
        引发:
        AssertionError: 如果断言失败。
        """
        comparators = {
            '>': lambda a, b: a > b,
            '<': lambda a, b: a < b,
            '==': lambda a, b: a == b,
            '>=': lambda a, b: a >= b,
            '<=': lambda a, b: a <= b,
            '!=': lambda a, b: a != b,
        }
    
        message = kwargs.get("MESSAGE", None)
    
        if kwargs["OP_STR"] not in comparators:
            raise ValueError(f"没有该操作方式: {kwargs['OP_STR']}")
    
        if not comparators[kwargs['OP_STR']](kwargs['VALUE'], kwargs["EXPECTED"]):
            if message:
                raise AssertionError(message)
            else:
>               raise AssertionError(f"{kwargs['VALUE']} {kwargs['OP_STR']} {kwargs['EXPECTED']} 失败")
E               AssertionError: SUCCESS == 书籍ID不存在 失败

extend\keywords.py:255: AssertionError conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:33 INFO 异常：<ExceptionInfo AssertionError('SUCCESS == 书籍ID不存在 失败') tblen=31> conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:33 INFO 用例耗时：0.09243060000000014 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:33 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:36 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u6211\u7684\u4e66\u8bc4-\u53d1\u5e03\u4e0d\u5b58\u5728\u7684\u4e66\u7c4dID\uff08BUG\uff09] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:36 INFO 测试结果：failed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:36 INFO 故障表示：self = <ApiTestRunner.TestRunner object at 0x000002A9B1226700>
caseinfo = {'_case_name': '我的书评-发布不存在的书籍ID（BUG）', 'desc': '我的书评-发布不存在的书籍ID（BUG）', 'featureName': '我的书评', 'steps': [{'发送Post请求': {..., {'断言-等于-CODE': {'EXPECTED': '200', 'OP_STR': '==', 'VALUE': '{{msg_code}}', '关键字': 'assert_text_comparators'}}], ...}

    def test_case_execute(self, caseinfo):
        print("当前的测试数据：", caseinfo)
        # TODO 2-1: 动态生成一下当前的测试用例标题
        # allure.dynamic.title(caseinfo["_case_name"])
    
        # TODO 2-1 : 调用动态生成标题的方法
        dynamicTitle(caseinfo)
    
        # TODO 2-2: 基于我们步骤一步步进行执行
        try:
            # 实例化关键字对象
            keywords = KeyWords()
    
            # 获取当前用例变量，方便后续的渲染
            local_context = caseinfo.get("context",{})
            context = copy.deepcopy(g_context().show_dict())
            context.update(local_context)
    
            steps = caseinfo.get("steps", None)
            for step in steps:
                #  提示信息
                step_name = list(step.keys())[0]
                step_value = list(step.values())[0]
                print(f"开始执行步骤：{step_name} - {step_value}")
    
                # TODO : 每一个步骤进行变量的渲染
                context = copy.deepcopy(g_context().show_dict())
                context.update(local_context)
                step_value = eval(refresh(step_value, context))
    
                # 基于每个步骤的关键字，找到对应的方法，然后把参数给它
                #  通过【反射】的方式去找到对应的方法
                with allure.step(step_name):
                    key = step_value["关键字"]  # 具体的方法名, 在 keywords 里面找到这个方法
                    try:
                        key_func = keywords.__getattribute__(key)  # 从keywords获取到对应方法
                    except AttributeError as e:
                        print("没有这个关键字方法", e)
>                   key_func(**step_value)  # 调用方法

core\ApiTestRunner.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <extend.keywords.KeyWords object at 0x000002A9B1334E80>
kwargs = {'EXPECTED': '书籍ID不存在', 'OP_STR': '==', 'VALUE': 'SUCCESS', '关键字': 'assert_text_comparators'}
comparators = {'!=': <function KeyWords.assert_text_comparators.<locals>.<lambda> at 0x000002A9B1339700>, '<': <function KeyWords.as...at 0x000002A9B1339790>, '==': <function KeyWords.assert_text_comparators.<locals>.<lambda> at 0x000002A9B1339820>, ...}
message = None

    @allure.step("参数数据：断言当前文本内容")
    def assert_text_comparators(self, **kwargs):
        """
        封装断言以进行不同的比较操作。
    
        参数:
        value (Any): 要比较的值。
        expected (Any): 预期的值。
        op_str (str): 操作符的字符串表示（如 '>', '<', '==' 等）。
        message (str, optional): 自定义的错误消息。
    
        返回:
        None: 如果断言成功，则不返回任何内容。
    
        引发:
        AssertionError: 如果断言失败。
        """
        comparators = {
            '>': lambda a, b: a > b,
            '<': lambda a, b: a < b,
            '==': lambda a, b: a == b,
            '>=': lambda a, b: a >= b,
            '<=': lambda a, b: a <= b,
            '!=': lambda a, b: a != b,
        }
    
        message = kwargs.get("MESSAGE", None)
    
        if kwargs["OP_STR"] not in comparators:
            raise ValueError(f"没有该操作方式: {kwargs['OP_STR']}")
    
        if not comparators[kwargs['OP_STR']](kwargs['VALUE'], kwargs["EXPECTED"]):
            if message:
                raise AssertionError(message)
            else:
>               raise AssertionError(f"{kwargs['VALUE']} {kwargs['OP_STR']} {kwargs['EXPECTED']} 失败")
E               AssertionError: SUCCESS == 书籍ID不存在 失败

extend\keywords.py:255: AssertionError conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:36 INFO 异常：<ExceptionInfo AssertionError('SUCCESS == 书籍ID不存在 失败') tblen=31> conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:36 INFO 用例耗时：0.07749800000000029 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:36 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:36 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u6211\u7684\u4e66\u8bc4-\u53d1\u5e03\u5df2\u8bc4\u4ef7\u7684\u6570\u636e] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:36 INFO 测试结果：passed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:36 INFO 故障表示：None conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:36 INFO 异常：None conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:36 INFO 用例耗时：0.06650849999999942 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:36 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:36 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u6211\u7684\u4e66\u8bc4-\u53d1\u5e03\u4e0d\u6ee1\u4e94\u4e2a\u5b57\u7684\u4e66\u8bc4\uff08BUG\uff09] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:36 INFO 测试结果：passed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:36 INFO 故障表示：None conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:36 INFO 异常：None conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:36 INFO 用例耗时：0.22834229999999955 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:36 INFO ************************************** conftest.py pytest_runtest_makereport 31
2024-08-02 19:33:37 INFO 用例ID：core/ApiTestRunner.py::TestRunner::test_case_execute[\u6211\u7684\u4e66\u8bc4-\u53d1\u5e03\u8d85\u8fc7200\u4e2a\u5b57\u7684\u4e66\u8bc4] conftest.py pytest_runtest_makereport 26
2024-08-02 19:33:37 INFO 测试结果：failed conftest.py pytest_runtest_makereport 27
2024-08-02 19:33:37 INFO 故障表示：self = <ApiTestRunner.TestRunner object at 0x000002A9B1226580>
caseinfo = {'_case_name': '我的书评-发布超过200个字的书评', 'desc': '我的书评-发布超过200个字的书评', 'featureName': '我的书评', 'steps': [{'提取评价的书籍ID': {'SQL'..., {'断言-等于-CODE': {'EXPECTED': '200', 'OP_STR': '==', 'VALUE': '{{msg_code}}', '关键字': 'assert_text_comparators'}}], ...}

    def test_case_execute(self, caseinfo):
        print("当前的测试数据：", caseinfo)
        # TODO 2-1: 动态生成一下当前的测试用例标题
        # allure.dynamic.title(caseinfo["_case_name"])
    
        # TODO 2-1 : 调用动态生成标题的方法
        dynamicTitle(caseinfo)
    
        # TODO 2-2: 基于我们步骤一步步进行执行
        try:
            # 实例化关键字对象
            keywords = KeyWords()
    
            # 获取当前用例变量，方便后续的渲染
            local_context = caseinfo.get("context",{})
            context = copy.deepcopy(g_context().show_dict())
            context.update(local_context)
    
            steps = caseinfo.get("steps", None)
            for step in steps:
                #  提示信息
                step_name = list(step.keys())[0]
                step_value = list(step.values())[0]
                print(f"开始执行步骤：{step_name} - {step_value}")
    
                # TODO : 每一个步骤进行变量的渲染
                context = copy.deepcopy(g_context().show_dict())
                context.update(local_context)
                step_value = eval(refresh(step_value, context))
    
                # 基于每个步骤的关键字，找到对应的方法，然后把参数给它
                #  通过【反射】的方式去找到对应的方法
                with allure.step(step_name):
                    key = step_value["关键字"]  # 具体的方法名, 在 keywords 里面找到这个方法
                    try:
                        key_func = keywords.__getattribute__(key)  # 从keywords获取到对应方法
                    except AttributeError as e:
                        print("没有这个关键字方法", e)
>                   key_func(**step_value)  # 调用方法

core\ApiTestRunner.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <extend.keywords.KeyWords object at 0x000002A9B13E5DC0>
kwargs = {'EXPECTED': '评价不能超过200字符！', 'OP_STR': '==', 'VALUE': 'SUCCESS', '关键字': 'assert_text_comparators'}
comparators = {'!=': <function KeyWords.assert_text_comparators.<locals>.<lambda> at 0x000002A9B1331C10>, '<': <function KeyWords.as...at 0x000002A9B13318B0>, '==': <function KeyWords.assert_text_comparators.<locals>.<lambda> at 0x000002A9B1331550>, ...}
message = None

    @allure.step("参数数据：断言当前文本内容")
    def assert_text_comparators(self, **kwargs):
        """
        封装断言以进行不同的比较操作。
    
        参数:
        value (Any): 要比较的值。
        expected (Any): 预期的值。
        op_str (str): 操作符的字符串表示（如 '>', '<', '==' 等）。
        message (str, optional): 自定义的错误消息。
    
        返回:
        None: 如果断言成功，则不返回任何内容。
    
        引发:
        AssertionError: 如果断言失败。
        """
        comparators = {
            '>': lambda a, b: a > b,
            '<': lambda a, b: a < b,
            '==': lambda a, b: a == b,
            '>=': lambda a, b: a >= b,
            '<=': lambda a, b: a <= b,
            '!=': lambda a, b: a != b,
        }
    
        message = kwargs.get("MESSAGE", None)
    
        if kwargs["OP_STR"] not in comparators:
            raise ValueError(f"没有该操作方式: {kwargs['OP_STR']}")
    
        if not comparators[kwargs['OP_STR']](kwargs['VALUE'], kwargs["EXPECTED"]):
            if message:
                raise AssertionError(message)
            else:
>               raise AssertionError(f"{kwargs['VALUE']} {kwargs['OP_STR']} {kwargs['EXPECTED']} 失败")
E               AssertionError: SUCCESS == 评价不能超过200字符！ 失败

extend\keywords.py:255: AssertionError conftest.py pytest_runtest_makereport 28
2024-08-02 19:33:37 INFO 异常：<ExceptionInfo AssertionError('SUCCESS == 评价不能超过200字符！ 失败') tblen=31> conftest.py pytest_runtest_makereport 29
2024-08-02 19:33:37 INFO 用例耗时：0.20639420000000008 conftest.py pytest_runtest_makereport 30
2024-08-02 19:33:37 INFO ************************************** conftest.py pytest_runtest_makereport 31
